From b20b262a7f839e83d5c1526a378445091f885ce5 Mon Sep 17 00:00:00 2001
From: Yuantian Tang <andy.tang@nxp.com>
Date: Thu, 10 Aug 2023 15:56:16 +0800
Subject: [PATCH 05/24] update i2c driver for imx9

---
 drivers/i2c/busses/Kconfig                 |  26 ++
 drivers/i2c/busses/Makefile                |   5 +-
 drivers/i2c/busses/i2c-designware-common.c |  11 +-
 drivers/i2c/busses/i2c-designware-core.h   |   9 +-
 drivers/i2c/busses/i2c-designware-master.c |  13 -
 drivers/i2c/busses/i2c-designware-pcidrv.c |   2 -
 drivers/i2c/busses/i2c-imx.c               |  20 +-
 drivers/i2c/busses/i2c-rk3x.c              |  44 +-
 drivers/i2c/busses/i2c-rpmsg-imx.c         |  47 +-
 drivers/i2c/busses/i2c-xiic.c              |   1 -
 drivers/i2c/busses/xen-i2cback.c           | 485 ++++++++++++++++++++
 drivers/i2c/busses/xen-i2cfront.c          | 507 +++++++++++++++++++++
 drivers/i2c/muxes/i2c-mux-pca954x.c        |   8 +
 drivers/i2c/muxes/i2c-mux-reg.c            |   5 +-
 include/xen/interface/io/i2cif.h           |  95 ++++
 15 files changed, 1204 insertions(+), 74 deletions(-)
 create mode 100644 drivers/i2c/busses/xen-i2cback.c
 create mode 100644 drivers/i2c/busses/xen-i2cfront.c
 create mode 100644 include/xen/interface/io/i2cif.h

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index c372b0cb1..8a6fb4dc5 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -957,6 +957,12 @@ config I2C_RK3X
 	  This driver can also be built as a module. If so, the module will
 	  be called i2c-rk3x.
 
+config I2C_RPBUS
+	tristate "I2C proxy bus over RPMSG"
+	depends on I2C && RPMSG
+	help
+	  This driver can support virtual i2c-rpmsg function.
+
 config HAVE_S3C2410_I2C
 	bool
 	help
@@ -1412,4 +1418,24 @@ config I2C_VIRTIO
           This driver can also be built as a module. If so, the module
           will be called i2c-virtio.
 
+config XEN_I2C_FRONTEND
+	tristate "Xen virtual i2c device support"
+	depends on XEN
+	default y
+	select XEN_XENBUS_FRONTEND
+	help
+	  This driver implements the front-end of the Xen virtual
+	  i2c device driver.  It communicates with a back-end driver
+	  in another domain which drives the actual i2c device.
+
+config XEN_I2C_BACKEND
+	tristate "Xen i2c-device backend driver"
+	depends on XEN_BACKEND
+	help
+	  The i2c-device backend driver allows the kernel to export its
+	  block devices to other guests.
+
+	  The corresponding Linux frontend driver is enabled by the
+	  CONFIG_XEN_I2C_FRONTEND configuration option.
+
 endmenu
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index c80d224d8..af8633c52 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -120,7 +120,6 @@ obj-$(CONFIG_I2C_XILINX)	+= i2c-xiic.o
 obj-$(CONFIG_I2C_XLR)		+= i2c-xlr.o
 obj-$(CONFIG_I2C_XLP9XX)	+= i2c-xlp9xx.o
 obj-$(CONFIG_I2C_RCAR)		+= i2c-rcar.o
-obj-$(CONFIG_I2C_RPBUS)		+= i2c-rpmsg-imx.o
 
 # External I2C/SMBus adapter drivers
 obj-$(CONFIG_I2C_DIOLAN_U2C)	+= i2c-diolan-u2c.o
@@ -128,6 +127,7 @@ obj-$(CONFIG_I2C_DLN2)		+= i2c-dln2.o
 obj-$(CONFIG_I2C_CP2615) += i2c-cp2615.o
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
 obj-$(CONFIG_I2C_ROBOTFUZZ_OSIF)	+= i2c-robotfuzz-osif.o
+obj-$(CONFIG_I2C_RPBUS)		+= i2c-rpmsg-imx.o
 obj-$(CONFIG_I2C_TAOS_EVM)	+= i2c-taos-evm.o
 obj-$(CONFIG_I2C_TINY_USB)	+= i2c-tiny-usb.o
 obj-$(CONFIG_I2C_VIPERBOARD)	+= i2c-viperboard.o
@@ -149,4 +149,7 @@ obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_I2C_FSI)		+= i2c-fsi.o
 obj-$(CONFIG_I2C_VIRTIO)	+= i2c-virtio.o
 
+obj-$(CONFIG_XEN_I2C_FRONTEND)	+= xen-i2cfront.o
+obj-$(CONFIG_XEN_I2C_BACKEND)	+= xen-i2cback.o
+
 ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
diff --git a/drivers/i2c/busses/i2c-designware-common.c b/drivers/i2c/busses/i2c-designware-common.c
index 4e752321b..a1100e376 100644
--- a/drivers/i2c/busses/i2c-designware-common.c
+++ b/drivers/i2c/busses/i2c-designware-common.c
@@ -351,8 +351,7 @@ u32 i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)
 		 *
 		 * If your hardware is free from tHD;STA issue, try this one.
 		 */
-		return DIV_ROUND_CLOSEST_ULL((u64)ic_clk * tSYMBOL, MICRO) -
-		       8 + offset;
+		return DIV_ROUND_CLOSEST(ic_clk * tSYMBOL, MICRO) - 8 + offset;
 	else
 		/*
 		 * Conditional expression:
@@ -368,8 +367,7 @@ u32 i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)
 		 * The reason why we need to take into account "tf" here,
 		 * is the same as described in i2c_dw_scl_lcnt().
 		 */
-		return DIV_ROUND_CLOSEST_ULL((u64)ic_clk * (tSYMBOL + tf), MICRO) -
-		       3 + offset;
+		return DIV_ROUND_CLOSEST(ic_clk * (tSYMBOL + tf), MICRO) - 3 + offset;
 }
 
 u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)
@@ -385,8 +383,7 @@ u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)
 	 * account the fall time of SCL signal (tf).  Default tf value
 	 * should be 0.3 us, for safety.
 	 */
-	return DIV_ROUND_CLOSEST_ULL((u64)ic_clk * (tLOW + tf), MICRO) -
-	       1 + offset;
+	return DIV_ROUND_CLOSEST(ic_clk * (tLOW + tf), MICRO) - 1 + offset;
 }
 
 int i2c_dw_set_sda_hold(struct dw_i2c_dev *dev)
@@ -465,7 +462,7 @@ void __i2c_dw_disable(struct dw_i2c_dev *dev)
 	dev_warn(dev->dev, "timeout in disabling adapter\n");
 }
 
-u32 i2c_dw_clk_rate(struct dw_i2c_dev *dev)
+unsigned long i2c_dw_clk_rate(struct dw_i2c_dev *dev)
 {
 	/*
 	 * Clock is not necessary if we got LCNT/HCNT values directly from
diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index 59b36e064..60a2e750c 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -126,9 +126,8 @@
  * status codes
  */
 #define STATUS_IDLE			0x0
-#define STATUS_ACTIVE			0x1
-#define STATUS_WRITE_IN_PROGRESS	0x2
-#define STATUS_READ_IN_PROGRESS		0x4
+#define STATUS_WRITE_IN_PROGRESS	0x1
+#define STATUS_READ_IN_PROGRESS		0x2
 
 /*
  * operation modes
@@ -310,7 +309,7 @@ int i2c_dw_init_regmap(struct dw_i2c_dev *dev);
 u32 i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset);
 u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset);
 int i2c_dw_set_sda_hold(struct dw_i2c_dev *dev);
-u32 i2c_dw_clk_rate(struct dw_i2c_dev *dev);
+unsigned long i2c_dw_clk_rate(struct dw_i2c_dev *dev);
 int i2c_dw_prepare_clk(struct dw_i2c_dev *dev, bool prepare);
 int i2c_dw_acquire_lock(struct dw_i2c_dev *dev);
 void i2c_dw_release_lock(struct dw_i2c_dev *dev);
@@ -323,14 +322,12 @@ void i2c_dw_disable_int(struct dw_i2c_dev *dev);
 
 static inline void __i2c_dw_enable(struct dw_i2c_dev *dev)
 {
-	dev->status |= STATUS_ACTIVE;
 	regmap_write(dev->map, DW_IC_ENABLE, 1);
 }
 
 static inline void __i2c_dw_disable_nowait(struct dw_i2c_dev *dev)
 {
 	regmap_write(dev->map, DW_IC_ENABLE, 0);
-	dev->status &= ~STATUS_ACTIVE;
 }
 
 void __i2c_dw_disable(struct dw_i2c_dev *dev);
diff --git a/drivers/i2c/busses/i2c-designware-master.c b/drivers/i2c/busses/i2c-designware-master.c
index e0559eff8..9b08bb5df 100644
--- a/drivers/i2c/busses/i2c-designware-master.c
+++ b/drivers/i2c/busses/i2c-designware-master.c
@@ -720,19 +720,6 @@ static int i2c_dw_irq_handler_master(struct dw_i2c_dev *dev)
 	u32 stat;
 
 	stat = i2c_dw_read_clear_intrbits(dev);
-
-	if (!(dev->status & STATUS_ACTIVE)) {
-		/*
-		 * Unexpected interrupt in driver point of view. State
-		 * variables are either unset or stale so acknowledge and
-		 * disable interrupts for suppressing further interrupts if
-		 * interrupt really came from this HW (E.g. firmware has left
-		 * the HW active).
-		 */
-		regmap_write(dev->map, DW_IC_INTR_MASK, 0);
-		return 0;
-	}
-
 	if (stat & DW_IC_INTR_TX_ABRT) {
 		dev->cmd_err |= DW_IC_ERR_TX_ABRT;
 		dev->status = STATUS_IDLE;
diff --git a/drivers/i2c/busses/i2c-designware-pcidrv.c b/drivers/i2c/busses/i2c-designware-pcidrv.c
index de8dd3e33..5b45941bc 100644
--- a/drivers/i2c/busses/i2c-designware-pcidrv.c
+++ b/drivers/i2c/busses/i2c-designware-pcidrv.c
@@ -398,8 +398,6 @@ static const struct pci_device_id i2_designware_pci_ids[] = {
 	{ PCI_VDEVICE(ATI,  0x73a4), navi_amd },
 	{ PCI_VDEVICE(ATI,  0x73e4), navi_amd },
 	{ PCI_VDEVICE(ATI,  0x73c4), navi_amd },
-	{ PCI_VDEVICE(ATI,  0x7444), navi_amd },
-	{ PCI_VDEVICE(ATI,  0x7464), navi_amd },
 	{ 0,}
 };
 MODULE_DEVICE_TABLE(pci, i2_designware_pci_ids);
diff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c
index fbf439281..97455283e 100644
--- a/drivers/i2c/busses/i2c-imx.c
+++ b/drivers/i2c/busses/i2c-imx.c
@@ -1742,9 +1742,7 @@ static int i2c_imx_remove(struct platform_device *pdev)
 	struct imx_i2c_struct *i2c_imx = platform_get_drvdata(pdev);
 	int irq, ret;
 
-	ret = pm_runtime_resume_and_get(&pdev->dev);
-	if (ret < 0)
-		return ret;
+	ret = pm_runtime_get_sync(&pdev->dev);
 
 	/* remove adapter */
 	dev_dbg(&i2c_imx->adapter.dev, "adapter removed\n");
@@ -1753,17 +1751,21 @@ static int i2c_imx_remove(struct platform_device *pdev)
 	if (i2c_imx->dma)
 		i2c_imx_dma_free(i2c_imx);
 
-	/* setup chip registers to defaults */
-	imx_i2c_write_reg(0, i2c_imx, IMX_I2C_IADR);
-	imx_i2c_write_reg(0, i2c_imx, IMX_I2C_IFDR);
-	imx_i2c_write_reg(0, i2c_imx, IMX_I2C_I2CR);
-	imx_i2c_write_reg(0, i2c_imx, IMX_I2C_I2SR);
+	if (ret >= 0) {
+		/* setup chip registers to defaults */
+		imx_i2c_write_reg(0, i2c_imx, IMX_I2C_IADR);
+		imx_i2c_write_reg(0, i2c_imx, IMX_I2C_IFDR);
+		imx_i2c_write_reg(0, i2c_imx, IMX_I2C_I2CR);
+		imx_i2c_write_reg(0, i2c_imx, IMX_I2C_I2SR);
+		clk_disable(i2c_imx->clk);
+	}
 
 	clk_notifier_unregister(i2c_imx->clk, &i2c_imx->clk_change_nb);
 	irq = platform_get_irq(pdev, 0);
 	if (irq >= 0)
 		free_irq(irq, i2c_imx);
-	clk_disable_unprepare(i2c_imx->clk);
+
+	clk_unprepare(i2c_imx->clk);
 
 	pm_runtime_put_noidle(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
diff --git a/drivers/i2c/busses/i2c-rk3x.c b/drivers/i2c/busses/i2c-rk3x.c
index 13c14eb17..02ddb237f 100644
--- a/drivers/i2c/busses/i2c-rk3x.c
+++ b/drivers/i2c/busses/i2c-rk3x.c
@@ -80,7 +80,7 @@ enum {
 #define DEFAULT_SCL_RATE  (100 * 1000) /* Hz */
 
 /**
- * struct i2c_spec_values - I2C specification values for various modes
+ * struct i2c_spec_values:
  * @min_hold_start_ns: min hold time (repeated) START condition
  * @min_low_ns: min LOW period of the SCL clock
  * @min_high_ns: min HIGH period of the SCL cloc
@@ -136,7 +136,7 @@ static const struct i2c_spec_values fast_mode_plus_spec = {
 };
 
 /**
- * struct rk3x_i2c_calced_timings - calculated V1 timings
+ * struct rk3x_i2c_calced_timings:
  * @div_low: Divider output for low
  * @div_high: Divider output for high
  * @tuning: Used to adjust setup/hold data time,
@@ -159,7 +159,7 @@ enum rk3x_i2c_state {
 };
 
 /**
- * struct rk3x_i2c_soc_data - SOC-specific data
+ * struct rk3x_i2c_soc_data:
  * @grf_offset: offset inside the grf regmap for setting the i2c type
  * @calc_timings: Callback function for i2c timing information calculated
  */
@@ -239,8 +239,7 @@ static inline void rk3x_i2c_clean_ipd(struct rk3x_i2c *i2c)
 }
 
 /**
- * rk3x_i2c_start - Generate a START condition, which triggers a REG_INT_START interrupt.
- * @i2c: target controller data
+ * Generate a START condition, which triggers a REG_INT_START interrupt.
  */
 static void rk3x_i2c_start(struct rk3x_i2c *i2c)
 {
@@ -259,8 +258,8 @@ static void rk3x_i2c_start(struct rk3x_i2c *i2c)
 }
 
 /**
- * rk3x_i2c_stop - Generate a STOP condition, which triggers a REG_INT_STOP interrupt.
- * @i2c: target controller data
+ * Generate a STOP condition, which triggers a REG_INT_STOP interrupt.
+ *
  * @error: Error code to return in rk3x_i2c_xfer
  */
 static void rk3x_i2c_stop(struct rk3x_i2c *i2c, int error)
@@ -299,8 +298,7 @@ static void rk3x_i2c_stop(struct rk3x_i2c *i2c, int error)
 }
 
 /**
- * rk3x_i2c_prepare_read - Setup a read according to i2c->msg
- * @i2c: target controller data
+ * Setup a read according to i2c->msg
  */
 static void rk3x_i2c_prepare_read(struct rk3x_i2c *i2c)
 {
@@ -331,8 +329,7 @@ static void rk3x_i2c_prepare_read(struct rk3x_i2c *i2c)
 }
 
 /**
- * rk3x_i2c_fill_transmit_buf - Fill the transmit buffer with data from i2c->msg
- * @i2c: target controller data
+ * Fill the transmit buffer with data from i2c->msg
  */
 static void rk3x_i2c_fill_transmit_buf(struct rk3x_i2c *i2c)
 {
@@ -535,10 +532,11 @@ static irqreturn_t rk3x_i2c_irq(int irqno, void *dev_id)
 }
 
 /**
- * rk3x_i2c_get_spec - Get timing values of I2C specification
+ * Get timing values of I2C specification
+ *
  * @speed: Desired SCL frequency
  *
- * Return: Matched i2c_spec_values.
+ * Returns: Matched i2c spec values.
  */
 static const struct i2c_spec_values *rk3x_i2c_get_spec(unsigned int speed)
 {
@@ -551,12 +549,13 @@ static const struct i2c_spec_values *rk3x_i2c_get_spec(unsigned int speed)
 }
 
 /**
- * rk3x_i2c_v0_calc_timings - Calculate divider values for desired SCL frequency
+ * Calculate divider values for desired SCL frequency
+ *
  * @clk_rate: I2C input clock rate
  * @t: Known I2C timing information
  * @t_calc: Caculated rk3x private timings that would be written into regs
  *
- * Return: %0 on success, -%EINVAL if the goal SCL rate is too slow. In that case
+ * Returns: 0 on success, -EINVAL if the goal SCL rate is too slow. In that case
  * a best-effort divider value is returned in divs. If the target rate is
  * too high, we silently use the highest possible rate.
  */
@@ -711,12 +710,13 @@ static int rk3x_i2c_v0_calc_timings(unsigned long clk_rate,
 }
 
 /**
- * rk3x_i2c_v1_calc_timings - Calculate timing values for desired SCL frequency
+ * Calculate timing values for desired SCL frequency
+ *
  * @clk_rate: I2C input clock rate
  * @t: Known I2C timing information
  * @t_calc: Caculated rk3x private timings that would be written into regs
  *
- * Return: %0 on success, -%EINVAL if the goal SCL rate is too slow. In that case
+ * Returns: 0 on success, -EINVAL if the goal SCL rate is too slow. In that case
  * a best-effort divider value is returned in divs. If the target rate is
  * too high, we silently use the highest possible rate.
  * The following formulas are v1's method to calculate timings.
@@ -960,14 +960,14 @@ static int rk3x_i2c_clk_notifier_cb(struct notifier_block *nb, unsigned long
 }
 
 /**
- * rk3x_i2c_setup - Setup I2C registers for an I2C operation specified by msgs, num.
- * @i2c: target controller data
- * @msgs: I2C msgs to process
- * @num: Number of msgs
+ * Setup I2C registers for an I2C operation specified by msgs, num.
  *
  * Must be called with i2c->lock held.
  *
- * Return: Number of I2C msgs processed or negative in case of error
+ * @msgs: I2C msgs to process
+ * @num: Number of msgs
+ *
+ * returns: Number of I2C msgs processed or negative in case of error
  */
 static int rk3x_i2c_setup(struct rk3x_i2c *i2c, struct i2c_msg *msgs, int num)
 {
diff --git a/drivers/i2c/busses/i2c-rpmsg-imx.c b/drivers/i2c/busses/i2c-rpmsg-imx.c
index 06e705271..a6c2c16ac 100644
--- a/drivers/i2c/busses/i2c-rpmsg-imx.c
+++ b/drivers/i2c/busses/i2c-rpmsg-imx.c
@@ -36,13 +36,13 @@
  *   +---------------+---+---+---+---+---+---+---+---+
  *   |       11      |         Return Value          |
  *   +---------------+---+---+---+---+---+---+---+---+
- *   |    12 ~ 13    |            BUS ID             |
+ *   |    12 ~ 13    |            Address            |
  *   +---------------+---+---+---+---+---+---+---+---+
- *   |    14 ~ 15    |            Address            |
+ *   |    14 ~ 15    |             Flags             |
  *   +---------------+---+---+---+---+---+---+---+---+
  *   |    16 ~ 17    |           Data Len            |
  *   +---------------+---+---+---+---+---+---+---+---+
- *   |    18 ~ 33    |        16 Bytes Data          |
+ *   |    18 ~ 495   |        478 Bytes Data         |
  *   +---------------+---+---+---+---+---+---+---+---+
  *
  * The definition of Return Value:
@@ -78,7 +78,7 @@
 #include <linux/delay.h>
 #include <linux/rpmsg.h>
 
-#define I2C_RPMSG_MAX_BUF_SIZE			16
+#define I2C_RPMSG_MAX_BUF_SIZE			478
 #define I2C_RPMSG_TIMEOUT			500 /* unit: ms */
 
 #define I2C_RPMSG_CATEGORY			0x09
@@ -91,6 +91,11 @@
 
 #define I2C_RPMSG_M_STOP			0x0200
 
+struct i2c_rpmsg_devtype_data {
+	unsigned int max_buf_size;
+	bool dynamic_buffer_support;
+};
+
 struct i2c_rpmsg_msg {
 	struct imx_rpmsg_head header;
 
@@ -107,6 +112,7 @@ struct i2c_rpmsg_info {
 	struct rpmsg_device *rpdev;
 	struct device *dev;
 	struct i2c_rpmsg_msg *msg;
+	const struct i2c_rpmsg_devtype_data *devtype_data;
 	struct completion cmd_complete;
 	struct mutex lock;
 
@@ -118,6 +124,7 @@ static struct i2c_rpmsg_info i2c_rpmsg;
 
 struct imx_rpmsg_i2c_data {
 	struct i2c_adapter adapter;
+	const struct i2c_rpmsg_devtype_data *devtype_data;
 };
 
 static int i2c_rpmsg_cb(struct rpmsg_device *rpdev, void *data, int len,
@@ -153,9 +160,14 @@ static int i2c_rpmsg_cb(struct rpmsg_device *rpdev, void *data, int len,
 static int rpmsg_xfer(struct i2c_rpmsg_msg *rmsg, struct i2c_rpmsg_info *info)
 {
 	int ret = 0;
+	int xfer_len = sizeof(struct i2c_rpmsg_msg) - I2C_RPMSG_MAX_BUF_SIZE;
+
+	if (info->devtype_data->dynamic_buffer_support)
+		xfer_len += rmsg->len;
+	else
+		xfer_len += info->devtype_data->max_buf_size;
 
-	ret = rpmsg_send(info->rpdev->ept, (void *)rmsg,
-						sizeof(struct i2c_rpmsg_msg));
+	ret = rpmsg_send(info->rpdev->ept, (void *)rmsg, xfer_len);
 	if (ret < 0) {
 		dev_err(&info->rpdev->dev, "rpmsg_send failed: %d\n", ret);
 		return ret;
@@ -186,10 +198,10 @@ static int i2c_rpmsg_read(struct i2c_msg *msg, struct i2c_rpmsg_info *info,
 	if (!info->rpdev)
 		return -EINVAL;
 
-	if (msg->len > I2C_RPMSG_MAX_BUF_SIZE) {
+	if (msg->len > info->devtype_data->max_buf_size) {
 		dev_err(&info->rpdev->dev,
 		"%s failed: data length greater than %d, len=%d\n",
-		__func__, I2C_RPMSG_MAX_BUF_SIZE, msg->len);
+		__func__, info->devtype_data->max_buf_size, msg->len);
 		return -EINVAL;
 	}
 
@@ -236,10 +248,10 @@ int i2c_rpmsg_write(struct i2c_msg *msg, struct i2c_rpmsg_info *info,
 	if (!info || !info->rpdev)
 		return -EINVAL;
 
-	if (msg->len > I2C_RPMSG_MAX_BUF_SIZE) {
+	if (msg->len > info->devtype_data->max_buf_size) {
 		dev_err(&info->rpdev->dev,
 		"%s failed: data length greater than %d, len=%d\n",
-		__func__, I2C_RPMSG_MAX_BUF_SIZE, msg->len);
+		__func__, info->devtype_data->max_buf_size, msg->len);
 		return -EINVAL;
 	}
 
@@ -329,6 +341,7 @@ static int i2c_rpbus_xfer(struct i2c_adapter *adapter,
 
 		pmsg = &msgs[i];
 
+		i2c_rpmsg.devtype_data = rdata->devtype_data;
 		i2c_rpmsg.bus_id = rdata->adapter.nr;
 		i2c_rpmsg.addr = pmsg->addr;
 
@@ -386,6 +399,7 @@ static int i2c_rpbus_probe(struct platform_device *pdev)
 	if (!rdata)
 		return -ENOMEM;
 
+	rdata->devtype_data = of_device_get_match_data(&pdev->dev);
 	adapter = &rdata->adapter;
 	/* setup i2c adapter description */
 	adapter->owner = THIS_MODULE;
@@ -429,8 +443,19 @@ static int i2c_rpbus_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static struct i2c_rpmsg_devtype_data i2c_rpmsg_devtype_data = {
+	.max_buf_size = 16,
+	.dynamic_buffer_support = false,
+};
+
+static struct i2c_rpmsg_devtype_data i2c_rpmsg_v2_devtype_data = {
+	.max_buf_size = I2C_RPMSG_MAX_BUF_SIZE,
+	.dynamic_buffer_support = true,
+};
+
 static const struct of_device_id imx_rpmsg_i2c_dt_ids[] = {
-	{ .compatible = "fsl,i2c-rpbus", },
+	{ .compatible = "fsl,i2c-rpbus", .data = &i2c_rpmsg_devtype_data},
+	{ .compatible = "fsl,i2c-rpbus-v2", .data = &i2c_rpmsg_v2_devtype_data},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, imx_rpmsg_i2c_dt_ids);
diff --git a/drivers/i2c/busses/i2c-xiic.c b/drivers/i2c/busses/i2c-xiic.c
index 34b8da949..612343771 100644
--- a/drivers/i2c/busses/i2c-xiic.c
+++ b/drivers/i2c/busses/i2c-xiic.c
@@ -934,7 +934,6 @@ static struct platform_driver xiic_i2c_driver = {
 
 module_platform_driver(xiic_i2c_driver);
 
-MODULE_ALIAS("platform:" DRIVER_NAME);
 MODULE_AUTHOR("info@mocean-labs.com");
 MODULE_DESCRIPTION("Xilinx I2C bus driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/i2c/busses/xen-i2cback.c b/drivers/i2c/busses/xen-i2cback.c
new file mode 100644
index 000000000..d742cd241
--- /dev/null
+++ b/drivers/i2c/busses/xen-i2cback.c
@@ -0,0 +1,485 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2018-2019 NXP
+ *
+ * Peng Fan <peng.fan@nxp.com>
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+
+#include <xen/xen.h>
+#include <xen/events.h>
+#include <xen/xenbus.h>
+#include <xen/grant_table.h>
+#include <xen/page.h>
+
+#include <xen/interface/grant_table.h>
+#include <xen/interface/io/i2cif.h>
+
+struct i2cback_info {
+	domid_t domid;
+	u32 irq;
+	u64 handle;
+	struct xenbus_device *i2cdev;
+	spinlock_t i2c_ring_lock;
+	struct i2cif_back_ring i2c_ring;
+	int is_connected;
+	int ring_error;
+	struct i2c_adapter *adapter;
+	u32 num_slaves;
+	u32 *allowed_slaves;
+};
+
+static bool i2cback_access_allowed(struct i2cback_info *info,
+				   struct i2cif_request *req)
+{
+	int i;
+
+	if (req->is_smbus) {/*check for smbus access permission*/
+		for (i = 0; i < info->num_slaves; i++)
+			if (req->addr == info->allowed_slaves[i])
+				return true;
+
+		return false;
+	}
+
+	/*check for master_xfer access permission*/
+	if (req->num_msg == I2CIF_MAX_MSG) {
+		if (req->msg[0].addr != req->msg[1].addr)
+			return false;
+	}
+
+	for (i = 0; i < info->num_slaves; i++) {
+		if (req->msg[0].addr == info->allowed_slaves[i])
+			return true;
+	}
+
+	return false;
+}
+
+static bool i2cback_handle_int(struct i2cback_info *info)
+{
+	struct i2cif_back_ring *i2c_ring = &info->i2c_ring;
+	struct i2cif_request req;
+	struct i2cif_response *res;
+	RING_IDX rc, rp;
+	int more_to_do, notify, num_msg = 0, ret;
+	struct i2c_msg msg[I2CIF_MAX_MSG];
+	union i2c_smbus_data smbus_data;
+	char tmp_buf[I2CIF_BUF_LEN];
+	unsigned long flags;
+	bool allow_access;
+	int i;
+
+	rc = i2c_ring->req_cons;
+	rp = i2c_ring->sring->req_prod;
+	rmb();	/* req_cons is written by frontend. */
+
+	if (RING_REQUEST_PROD_OVERFLOW(i2c_ring, rp)) {
+		rc = i2c_ring->rsp_prod_pvt;
+		dev_err(&info->i2cdev->dev, "ring overflow\n");
+		info->ring_error = 1;
+		return 0;
+	}
+
+	while (rc != rp) {
+		if (RING_REQUEST_CONS_OVERFLOW(i2c_ring, rc)) {
+			dev_err(&info->i2cdev->dev, "%s overflow\n", __func__);
+			break;
+		}
+
+		req = *RING_GET_REQUEST(i2c_ring, rc);
+		allow_access = i2cback_access_allowed(info, &req);
+		if (allow_access && !req.is_smbus) {
+			/* Write/Read sequence */
+			num_msg = req.num_msg;
+			if (num_msg > I2CIF_MAX_MSG)
+				num_msg = I2CIF_MAX_MSG;
+
+			for (i = 0; i < num_msg; i++) {
+				msg[i].addr = req.msg[i].addr;
+				msg[i].len = req.msg[i].len;
+				msg[i].flags = 0;
+				if (req.msg[i].flags & I2CIF_M_RD)
+					msg[i].flags |= I2C_M_RD;
+				if (req.msg[i].flags & I2CIF_M_TEN)
+					msg[i].flags |= I2C_M_TEN;
+				if (req.msg[i].flags & I2CIF_M_RECV_LEN)
+					msg[i].flags |= I2C_M_RECV_LEN;
+				if (req.msg[i].flags & I2CIF_M_NO_RD_ACK)
+					msg[i].flags |= I2C_M_NO_RD_ACK;
+				if (req.msg[i].flags & I2CIF_M_IGNORE_NAK)
+					msg[i].flags |= I2C_M_IGNORE_NAK;
+				if (req.msg[i].flags & I2CIF_M_REV_DIR_ADDR)
+					msg[i].flags |= I2C_M_REV_DIR_ADDR;
+				if (req.msg[i].flags & I2CIF_M_NOSTART)
+					msg[i].flags |= I2C_M_NOSTART;
+				if (req.msg[i].flags & I2CIF_M_STOP)
+					msg[i].flags |= I2C_M_STOP;
+			}
+
+			if ((num_msg == 2) &&
+			    (!(msg[0].flags & I2C_M_RD)) &&
+			    (msg[1].flags & I2C_M_RD)) {
+
+				/* overwrite the remote buf with local buf */
+				msg[0].buf = tmp_buf;
+				msg[1].buf = tmp_buf;
+
+				/* msg[0] write buf */
+				memcpy(tmp_buf, req.write_buf, I2CIF_BUF_LEN);
+				ret = i2c_transfer(info->adapter, msg,
+						   num_msg);
+			} else if (num_msg == 1) {
+				msg[0].buf = tmp_buf;
+				if (!(msg[0].flags & I2C_M_RD))
+					memcpy(tmp_buf, req.write_buf,
+					       I2CIF_BUF_LEN);
+				ret = i2c_transfer(info->adapter, msg,
+						   req.num_msg);
+			} else {
+				dev_dbg(&info->i2cdev->dev, "too many msgs\n");
+
+				ret = -EIO;
+			}
+		} else if (allow_access && req.is_smbus) {
+			memcpy(&smbus_data, &req.write_buf, sizeof(smbus_data));
+
+			ret = i2c_smbus_xfer(info->adapter,
+								req.addr,
+								req.flags,
+								req.read_write,
+								req.command,
+								req.protocol,
+								&smbus_data);
+		}
+
+		spin_lock_irqsave(&info->i2c_ring_lock, flags);
+		res = RING_GET_RESPONSE(&info->i2c_ring,
+					info->i2c_ring.rsp_prod_pvt);
+
+		if (allow_access && !req.is_smbus) {
+			res->result = ret;
+
+			if ((req.num_msg == 2) &&
+			    (!(msg[0].flags & I2C_M_RD)) &&
+			    (msg[1].flags & I2C_M_RD) && (ret >= 0)) {
+				memcpy(res->read_buf, tmp_buf, I2CIF_BUF_LEN);
+			} else if (req.num_msg == 1) {
+				if ((msg[0].flags & I2C_M_RD) && (ret >= 0))
+					memcpy(res->read_buf, tmp_buf,
+					       I2CIF_BUF_LEN);
+			}
+		} else if (allow_access && req.is_smbus) {
+			if (req.read_write == I2C_SMBUS_READ)
+				memcpy(&res->read_buf, &smbus_data, sizeof(smbus_data));
+			res->result = ret;
+		} else
+			res->result = -EPERM;
+
+		info->i2c_ring.rsp_prod_pvt++;
+
+		barrier();
+		RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&info->i2c_ring,
+						     notify);
+		spin_unlock_irqrestore(&info->i2c_ring_lock, flags);
+
+		if (notify)
+			notify_remote_via_irq(info->irq);
+
+		i2c_ring->req_cons = ++rc;
+
+		cond_resched();
+	}
+
+	RING_FINAL_CHECK_FOR_REQUESTS(i2c_ring, more_to_do);
+
+	return !!more_to_do;
+}
+
+static irqreturn_t i2cback_be_int(int irq, void *dev_id)
+{
+	struct i2cback_info *info = dev_id;
+
+	if (info->ring_error)
+		return IRQ_HANDLED;
+
+	while (i2cback_handle_int(info))
+		cond_resched();
+
+	return IRQ_HANDLED;
+}
+
+static int i2cback_map(struct i2cback_info *info, grant_ref_t *i2c_ring_ref,
+		       evtchn_port_t evtchn)
+{
+	int err;
+	void *addr;
+	struct i2cif_sring *i2c_sring;
+
+	if (info->irq)
+		return 0;
+
+	err = xenbus_map_ring_valloc(info->i2cdev, i2c_ring_ref, 1, &addr);
+	if (err)
+		return err;
+
+	i2c_sring = addr;
+
+	BACK_RING_INIT(&info->i2c_ring, i2c_sring, PAGE_SIZE);
+
+	err = bind_interdomain_evtchn_to_irq_lateeoi(info->i2cdev, evtchn);
+	if (err < 0)
+		goto fail_evtchn;
+	info->irq = err;
+
+	err = request_threaded_irq(info->irq, NULL, i2cback_be_int,
+				   IRQF_ONESHOT, "xen-i2cback", info);
+	if (err) {
+		dev_err(&info->i2cdev->dev, "bind evtchn to irq failure!\n");
+		goto free_irq;
+	}
+
+	return 0;
+free_irq:
+	unbind_from_irqhandler(info->irq, info);
+	info->irq = 0;
+	info->i2c_ring.sring = NULL;
+fail_evtchn:
+	xenbus_unmap_ring_vfree(info->i2cdev, i2c_sring);
+	return err;
+}
+
+static int i2cback_connect_rings(struct i2cback_info *info)
+{
+	struct xenbus_device *dev = info->i2cdev;
+	unsigned int i2c_ring_ref, evtchn;
+	int i, err;
+	char *buf;
+	u32 adapter_id;
+
+	err = xenbus_scanf(XBT_NIL, dev->nodename,
+			   "adapter", "%u", &adapter_id);
+	if (err != 1) {
+		xenbus_dev_fatal(dev, err, "%s reading adapter", dev->nodename);
+		return err;
+	}
+
+	info->adapter = i2c_get_adapter(adapter_id);
+	if (!info->adapter)
+		return -ENODEV;
+
+	err = xenbus_scanf(XBT_NIL, dev->nodename,
+			   "num-slaves", "%u", &info->num_slaves);
+	if (err != 1) {
+		xenbus_dev_fatal(dev, err, "%s reading num-slaves",
+				 dev->nodename);
+		return err;
+	}
+
+	info->allowed_slaves = devm_kmalloc(&dev->dev,
+					    info->num_slaves * sizeof(u32),
+					    GFP_KERNEL);
+	if (!info->allowed_slaves)
+		return -ENOMEM;
+
+	/* 128 bytes is enough */
+	buf = kmalloc(128, GFP_KERNEL);
+
+	for (i = 0; i < info->num_slaves; i++) {
+		snprintf(buf, 128, "%s/%d", dev->nodename, i);
+		err = xenbus_scanf(XBT_NIL, buf, "addr", "%x",
+				   &info->allowed_slaves[i]);
+		if (err != 1) {
+			kfree(buf);
+			return err;
+		}
+	}
+
+	kfree(buf);
+
+	err = xenbus_gather(XBT_NIL, dev->otherend,
+			    "ring-ref", "%u", &i2c_ring_ref,
+			    "event-channel", "%u", &evtchn, NULL);
+	if (err) {
+		xenbus_dev_fatal(dev, err,
+				 "reading %s/ring-ref and event-channel",
+				 dev->otherend);
+		return err;
+	}
+
+	dev_info(&info->i2cdev->dev,
+		 "xen-pvi2c: ring-ref %u, event-channel %u\n",
+		 i2c_ring_ref, evtchn);
+
+	err = i2cback_map(info, &i2c_ring_ref, evtchn);
+	if (err)
+		xenbus_dev_fatal(dev, err, "mapping ring-ref %u evtchn %u",
+			i2c_ring_ref, evtchn);
+
+	return err;
+}
+
+static void i2cback_disconnect(struct i2cback_info *info)
+{
+	if (info->irq) {
+		unbind_from_irqhandler(info->irq, info);
+		info->irq = 0;
+	}
+
+	if (info->i2c_ring.sring) {
+		xenbus_unmap_ring_vfree(info->i2cdev, info->i2c_ring.sring);
+		info->i2c_ring.sring = NULL;
+	}
+}
+
+static void i2cback_frontend_changed(struct xenbus_device *dev,
+				     enum xenbus_state frontend_state)
+{
+	struct i2cback_info *info = dev_get_drvdata(&dev->dev);
+	int ret;
+
+	switch (frontend_state) {
+	case XenbusStateInitialised:
+	case XenbusStateReconfiguring:
+	case XenbusStateReconfigured:
+		break;
+
+	case XenbusStateInitialising:
+		if (dev->state == XenbusStateClosed) {
+			dev_info(&dev->dev,
+				 "xen-pvi2c: %s: prepare for reconnect\n",
+				 dev->nodename);
+			xenbus_switch_state(dev, XenbusStateInitWait);
+		}
+		break;
+	case XenbusStateConnected:
+		if (dev->state == XenbusStateConnected)
+			break;
+
+		xenbus_switch_state(dev, XenbusStateConnected);
+
+		ret = i2cback_connect_rings(info);
+		if (ret)
+			xenbus_dev_fatal(dev, ret, "connect ring fail");
+		break;
+	case XenbusStateClosing:
+		i2cback_disconnect(info);
+		xenbus_switch_state(dev, XenbusStateClosing);
+		break;
+	case XenbusStateClosed:
+		xenbus_switch_state(dev, XenbusStateClosed);
+		if (xenbus_dev_is_online(dev))
+			break;
+		device_unregister(&dev->dev);
+		break;
+	case XenbusStateUnknown:
+		device_unregister(&dev->dev);
+		break;
+
+	default:
+		xenbus_dev_fatal(dev, -EINVAL, "saw state %d at frontend",
+				 frontend_state);
+		break;
+	}
+}
+
+static struct i2cback_info *i2cback_alloc(domid_t domid, u64 handle)
+{
+	struct i2cback_info *info;
+
+	info = kzalloc(sizeof(struct i2cback_info), GFP_KERNEL);
+	if (!info)
+		return NULL;
+
+	info->domid = domid;
+	info->handle = handle;
+	spin_lock_init(&info->i2c_ring_lock);
+	info->ring_error = 0;
+
+	return info;
+}
+
+static int i2cback_probe(struct xenbus_device *dev,
+			     const struct xenbus_device_id *id)
+{
+	struct i2cback_info *info;
+	unsigned long handle;
+	int err;
+
+	if (kstrtoul(strrchr(dev->otherend, '/') + 1, 0, &handle))
+		return -EINVAL;
+
+	info = i2cback_alloc(dev->otherend_id, handle);
+	if (!info) {
+		xenbus_dev_fatal(dev, -ENOMEM, "Allocating backend interface");
+		return -ENOMEM;
+	}
+
+	info->i2cdev = dev;
+	dev_set_drvdata(&dev->dev, info);
+
+	err = xenbus_switch_state(dev, XenbusStateInitWait);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int i2cback_remove(struct xenbus_device *dev)
+{
+	struct i2cback_info *info = dev_get_drvdata(&dev->dev);
+
+	if (!info)
+		return 0;
+
+	i2cback_disconnect(info);
+
+	kfree(info);
+	dev_set_drvdata(&dev->dev, NULL);
+
+	dev_info(&dev->dev, "%s\n", __func__);
+
+	return 0;
+}
+
+static const struct xenbus_device_id i2cback_ids[] = {
+	{ "vi2c" },
+	{ "" },
+};
+
+static struct xenbus_driver i2cback_driver = {
+	.ids			= i2cback_ids,
+	.probe			= i2cback_probe,
+	.otherend_changed	= i2cback_frontend_changed,
+	.remove			= i2cback_remove,
+};
+
+static int __init i2cback_init(void)
+{
+	int err;
+
+	if (!xen_domain())
+		return -ENODEV;
+
+	err = xenbus_register_backend(&i2cback_driver);
+	if (err)
+		return err;
+
+	return 0;
+}
+module_init(i2cback_init);
+
+static void __exit i2cback_exit(void)
+{
+	xenbus_unregister_driver(&i2cback_driver);
+}
+module_exit(i2cback_exit);
+
+MODULE_ALIAS("xen-i2cback:vi2c");
+MODULE_AUTHOR("Peng Fan <peng.fan@nxp.com>");
+MODULE_DESCRIPTION("Xen I2C backend driver (i2cback)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/busses/xen-i2cfront.c b/drivers/i2c/busses/xen-i2cfront.c
new file mode 100644
index 000000000..6b8702074
--- /dev/null
+++ b/drivers/i2c/busses/xen-i2cfront.c
@@ -0,0 +1,507 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2018 NXP
+ *
+ * Peng Fan <peng.fan@nxp.com>
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/list.h>
+#include <linux/io.h>
+
+#include <xen/xen.h>
+#include <xen/xenbus.h>
+#include <xen/grant_table.h>
+#include <xen/events.h>
+#include <xen/page.h>
+
+#include <xen/interface/io/i2cif.h>
+
+#define GRANT_INVALID_REF	0
+
+struct i2cfront_info {
+	spinlock_t lock;
+	struct mutex xferlock;
+	struct i2c_adapter adapter;
+	struct xenbus_device *i2cdev;
+	int i2c_ring_ref;
+	struct i2cif_front_ring i2c_ring;
+	unsigned int evtchn;
+	unsigned int irq;
+	struct completion completion;
+	struct i2cif_request *req;
+	struct i2cif_response *res;
+};
+
+static void i2cfront_destroy_rings(struct i2cfront_info *info)
+{
+	if (info->irq)
+		unbind_from_irqhandler(info->irq, info);
+	info->irq = 0;
+
+	if (info->i2c_ring_ref != GRANT_INVALID_REF) {
+		gnttab_end_foreign_access(info->i2c_ring_ref, 0,
+					  (unsigned long)info->i2c_ring.sring);
+		info->i2c_ring_ref = GRANT_INVALID_REF;
+	}
+	info->i2c_ring.sring = NULL;
+}
+
+static int i2cfront_do_req(struct i2c_adapter *adapter, struct i2c_msg *msg,
+			   int num)
+{
+	struct i2cfront_info *info = i2c_get_adapdata(adapter);
+	struct i2cif_request *req;
+	struct i2cif_response *res;
+	int notify;
+	int ret;
+	RING_IDX i, rp;
+	int more_to_do = 0;
+	unsigned long flags;
+	int index;
+
+	mutex_lock(&info->xferlock);
+	req = RING_GET_REQUEST(&info->i2c_ring, info->i2c_ring.req_prod_pvt);
+
+	for (index = 0; index < num; index++) {
+		req->msg[index].addr = msg[index].addr;
+		req->msg[index].len = msg[index].len;
+		req->msg[index].flags = 0;
+		if (msg[index].flags & I2C_M_RD)
+			req->msg[index].flags |= I2CIF_M_RD;
+		if (msg[index].flags & I2C_M_TEN)
+			req->msg[index].flags |= I2CIF_M_TEN;
+		if (msg[index].flags & I2C_M_RECV_LEN)
+			req->msg[index].flags |= I2CIF_M_RECV_LEN;
+		if (msg[index].flags & I2C_M_NO_RD_ACK)
+			req->msg[index].flags |= I2CIF_M_NO_RD_ACK;
+		if (msg[index].flags & I2C_M_IGNORE_NAK)
+			req->msg[index].flags |= I2CIF_M_IGNORE_NAK;
+		if (msg[index].flags & I2C_M_REV_DIR_ADDR)
+			req->msg[index].flags |= I2CIF_M_REV_DIR_ADDR;
+		if (msg[index].flags & I2C_M_NOSTART)
+			req->msg[index].flags |= I2CIF_M_NOSTART;
+		if (msg[index].flags & I2C_M_STOP)
+			req->msg[index].flags |= I2CIF_M_STOP;
+	}
+
+	req->num_msg = num;
+	req->is_smbus = false;
+
+	if ((num == 2) && !(msg[0].flags & I2C_M_RD) &&
+	    (msg[1].flags & I2C_M_RD)) {
+		memcpy(req->write_buf, msg[0].buf,
+		       min_t(int, msg[0].len, I2CIF_BUF_LEN));
+	} else if (num == 1) {
+		if (!(msg->flags & I2C_M_RD))
+			memcpy(req->write_buf, msg->buf,
+			       min_t(int, msg->len, I2CIF_BUF_LEN));
+	} else {
+		dev_err(&adapter->dev, "%s not supported\n", __func__);
+		return -EIO;
+	}
+
+	spin_lock(&info->lock);
+	info->i2c_ring.req_prod_pvt++;
+	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->i2c_ring, notify);
+	spin_unlock(&info->lock);
+	if (notify)
+		notify_remote_via_irq(info->irq);
+
+	wait_for_completion(&info->completion);
+
+	spin_lock_irqsave(&info->lock, flags);
+	rp = info->i2c_ring.sring->rsp_prod;
+	rmb(); /* ensure we see queued responses up to "rp" */
+
+	ret = -EIO;
+	for (i = info->i2c_ring.rsp_cons; i != rp; i++) {
+		res = RING_GET_RESPONSE(&info->i2c_ring, i);
+		if ((num == 2) && !(msg[0].flags & I2C_M_RD) &&
+		    (msg[1].flags & I2C_M_RD)) {
+			memcpy(msg[1].buf, res->read_buf,
+			       min_t(int, msg[1].len, I2CIF_BUF_LEN));
+		} else if (num == 1) {
+			if (!(msg->flags & I2C_M_RD))
+				memcpy(msg->buf, res->read_buf,
+				       min_t(int, msg->len, I2CIF_BUF_LEN));
+		}
+
+		ret = res->result;
+	}
+
+	info->i2c_ring.rsp_cons = i;
+
+	if (i != info->i2c_ring.req_prod_pvt)
+		RING_FINAL_CHECK_FOR_RESPONSES(&info->i2c_ring, more_to_do);
+	else
+		info->i2c_ring.sring->rsp_event = i + 1;
+
+	spin_unlock_irqrestore(&info->lock, flags);
+
+	mutex_unlock(&info->xferlock);
+
+	return ret;
+}
+
+int i2cfront_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)
+{
+	struct i2cfront_info *info = i2c_get_adapdata(adapter);
+	int ret, i;
+
+	if (!info || !info->i2cdev) {
+		dev_err(&adapter->dev, "Not initialized\n");
+		return -EIO;
+	}
+
+	if (info->i2cdev->state != XenbusStateConnected) {
+		dev_err(&adapter->dev, "Not connected\n");
+		return -EIO;
+	}
+
+	for (i = 0; i < num; i++) {
+		if (msgs[i].flags & I2C_M_RD) {
+			ret = i2cfront_do_req(adapter, &msgs[i], 1);
+		} else if ((i + 1 < num) && (msgs[i + 1].flags & I2C_M_RD) &&
+			(msgs[i].addr == msgs[i + 1].addr)) {
+			ret = i2cfront_do_req(adapter, &msgs[i], 2);
+			i++;
+		} else {
+			ret = i2cfront_do_req(adapter, &msgs[i], 1);
+		}
+
+		if (ret < 0)
+			goto err;
+	}
+err:
+	return (ret < 0) ? ret : num;
+}
+
+static int i2cfront_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
+        unsigned short flags, char read_write,
+        u8 command, int size, union i2c_smbus_data *data)
+{
+	struct i2cfront_info *info = i2c_get_adapdata(adapter);
+	struct i2cif_response *res;
+	struct i2cif_request *req;
+	unsigned long lock_flags;
+	int more_to_do = 0;
+	RING_IDX i, rp;
+	int notify;
+	int ret;
+
+	if (!info || !info->i2cdev) {
+		dev_err(&adapter->dev, "Not initialized\n");
+		return -EIO;
+	}
+
+	if (info->i2cdev->state != XenbusStateConnected) {
+		dev_err(&adapter->dev, "Not connected\n");
+		return -EIO;
+	}
+
+	mutex_lock(&info->xferlock);
+	req = RING_GET_REQUEST(&info->i2c_ring, info->i2c_ring.req_prod_pvt);
+
+	req->is_smbus = true;
+	req->addr = addr;
+	req->flags = flags;
+	req->read_write = read_write;
+	req->command = command;
+	req->protocol = size;
+	if (data != NULL)
+		memcpy(&req->write_buf, data, sizeof(union i2c_smbus_data));
+
+	spin_lock(&info->lock);
+	info->i2c_ring.req_prod_pvt++;
+	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->i2c_ring, notify);
+	spin_unlock(&info->lock);
+	if (notify)
+		notify_remote_via_irq(info->irq);
+
+	wait_for_completion(&info->completion);
+
+	spin_lock_irqsave(&info->lock, lock_flags);
+	rp = info->i2c_ring.sring->rsp_prod;
+	rmb(); /* ensure we see queued responses up to "rp" */
+
+	ret = -EIO;
+	for (i = info->i2c_ring.rsp_cons; i != rp; i++) {
+		res = RING_GET_RESPONSE(&info->i2c_ring, i);
+
+		if (data != NULL && read_write == I2C_SMBUS_READ)
+			memcpy(data, &res->read_buf, sizeof(union i2c_smbus_data));
+
+		ret = res->result;
+	}
+
+	info->i2c_ring.rsp_cons = i;
+
+	if (i != info->i2c_ring.req_prod_pvt)
+		RING_FINAL_CHECK_FOR_RESPONSES(&info->i2c_ring, more_to_do);
+	else
+		info->i2c_ring.sring->rsp_event = i + 1;
+
+	spin_unlock_irqrestore(&info->lock, lock_flags);
+
+	mutex_unlock(&info->xferlock);
+
+	return ret;
+}
+
+static u32 i2cfront_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE_DATA |
+			I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_QUICK |
+			I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+static const struct i2c_algorithm i2cfront_algo = {
+	.master_xfer = i2cfront_xfer,
+	.smbus_xfer = i2cfront_smbus_xfer,
+	.functionality = i2cfront_func,
+};
+
+static int i2cfront_probe(struct xenbus_device *dev,
+			  const struct xenbus_device_id *id)
+{
+	struct i2cfront_info *info;
+
+	info = kzalloc(sizeof(struct i2cfront_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->i2cdev = dev;
+	dev_set_drvdata(&dev->dev, info);
+	info->adapter.owner = THIS_MODULE;
+	info->adapter.algo = &i2cfront_algo;
+	info->adapter.dev.parent = &dev->dev;
+	strlcpy(info->adapter.name, dev->nodename, sizeof(info->adapter.name));
+	i2c_set_adapdata(&info->adapter, info);
+	spin_lock_init(&info->lock);
+	mutex_init(&info->xferlock);
+	init_completion(&info->completion);
+
+	return 0;
+}
+
+static int i2cfront_handle_int(struct i2cfront_info *info)
+{
+	complete(&info->completion);
+
+	return 0;
+}
+
+static irqreturn_t i2cfront_int(int irq, void *dev_id)
+{
+	struct i2cfront_info *info = dev_id;
+
+	while (i2cfront_handle_int(info))
+		cond_resched();
+
+	return IRQ_HANDLED;
+}
+
+static int i2cfront_setup_rings(struct xenbus_device *dev,
+				struct i2cfront_info *info)
+{
+	struct i2cif_sring *i2c_sring;
+	grant_ref_t gref;
+	int err;
+
+	info->i2c_ring_ref = GRANT_INVALID_REF;
+	i2c_sring = (struct i2cif_sring *)get_zeroed_page(GFP_NOIO |
+							  __GFP_HIGH);
+	if (!i2c_sring) {
+		xenbus_dev_fatal(dev, -ENOMEM, "allocating i2c sring");
+		return -ENOMEM;
+	}
+
+	SHARED_RING_INIT(i2c_sring);
+	FRONT_RING_INIT(&info->i2c_ring, i2c_sring, PAGE_SIZE);
+
+	err = xenbus_grant_ring(dev, i2c_sring, 1, &gref);
+	if (err < 0) {
+		free_page((unsigned long)i2c_sring);
+		info->i2c_ring.sring = NULL;
+		goto fail;
+	}
+	info->i2c_ring_ref = gref;
+
+	err = xenbus_alloc_evtchn(dev, &info->evtchn);
+	if (err) {
+		xenbus_dev_fatal(dev, err, "xenbus_alloc_evtchn");
+		goto fail;
+	}
+
+	err = bind_evtchn_to_irqhandler(info->evtchn, i2cfront_int, 0,
+					"xen_i2cif", info);
+	if (err <= 0) {
+		xenbus_dev_fatal(dev, err, "bind_evtchn_to_irqhandler failed");
+		goto fail;
+	}
+
+	info->irq = err;
+
+	return 0;
+
+fail:
+	i2cfront_destroy_rings(info);
+	return err;
+}
+
+static int i2cfront_connect(struct xenbus_device *dev)
+{
+	struct i2cfront_info *info = dev_get_drvdata(&dev->dev);
+	struct xenbus_transaction xbt;
+	struct device_node *np;
+	const char *be_adapter;
+	char xenstore_adapter[I2CIF_ADAPTER_NAME_LEN];
+	char *message;
+	int err;
+
+	err = i2cfront_setup_rings(dev, info);
+	if (err) {
+		dev_err(&dev->dev, "%s:failure....", __func__);
+		return err;
+	}
+again:
+	err = xenbus_transaction_start(&xbt);
+	if (err) {
+		xenbus_dev_fatal(dev, err, "starting transaction");
+		goto destroy_ring;
+	}
+
+	err = xenbus_printf(xbt, dev->nodename, "ring-ref", "%u",
+			    info->i2c_ring_ref);
+	if (err) {
+		message = "writing i2c ring-ref";
+		goto abort_transaction;
+	}
+
+	err = xenbus_printf(xbt, dev->nodename, "event-channel", "%u",
+			    info->evtchn);
+	if (err) {
+		message = "writing event-channel";
+		goto abort_transaction;
+	}
+
+	err = xenbus_scanf(xbt, dev->nodename,
+			   "be-adapter", "%32s", xenstore_adapter);
+	if (err != 1) {
+		message = "getting be-adapter";
+		goto abort_transaction;
+	}
+
+	err = xenbus_transaction_end(xbt, 0);
+	if (err) {
+		if (err == -EAGAIN)
+			goto again;
+		xenbus_dev_fatal(dev, err, "completing transaction");
+		goto destroy_ring;
+	}
+
+	for_each_compatible_node(np, NULL, "xen,i2c") {
+		err = of_property_read_string(np, "be-adapter", &be_adapter);
+		if (err)
+			continue;
+		if (!strncmp(xenstore_adapter, be_adapter,
+		    I2CIF_ADAPTER_NAME_LEN)) {
+			info->adapter.dev.of_node = np;
+			break;
+		}
+	}
+
+	err = i2c_add_adapter(&info->adapter);
+	if (err)
+		return err;
+
+	dev_info(&info->adapter.dev, "XEN I2C adapter registered\n");
+
+	return 0;
+
+abort_transaction:
+	xenbus_transaction_end(xbt, 1);
+	xenbus_dev_fatal(dev, err, "%s", message);
+
+destroy_ring:
+	i2cfront_destroy_rings(info);
+
+	return err;
+}
+
+static void i2cfront_disconnect(struct xenbus_device *dev)
+{
+	pr_info("%s\n", __func__);
+	xenbus_frontend_closed(dev);
+}
+
+static void i2cfront_backend_changed(struct xenbus_device *dev,
+				     enum xenbus_state backend_state)
+{
+	switch (backend_state) {
+	case XenbusStateInitialising:
+	case XenbusStateReconfiguring:
+	case XenbusStateReconfigured:
+	case XenbusStateUnknown:
+		break;
+
+	case XenbusStateInitWait:
+	case XenbusStateInitialised:
+	case XenbusStateConnected:
+		if (dev->state != XenbusStateInitialising)
+			break;
+		if (!i2cfront_connect(dev))
+			xenbus_switch_state(dev, XenbusStateConnected);
+		break;
+
+	case XenbusStateClosed:
+		if (dev->state == XenbusStateClosed)
+			break;
+		i2cfront_disconnect(dev);
+		break;
+	case XenbusStateClosing:
+		i2cfront_disconnect(dev);
+		break;
+
+	default:
+		xenbus_dev_fatal(dev, -EINVAL, "saw state %d at frontend",
+				 backend_state);
+		break;
+	}
+}
+
+static int i2cfront_remove(struct xenbus_device *dev)
+{
+	struct i2cfront_info *info = dev_get_drvdata(&dev->dev);
+
+	i2c_del_adapter(&info->adapter);
+	i2cfront_destroy_rings(info);
+
+	kfree(info);
+
+	dev_info(&dev->dev, "Remove");
+	return 0;
+}
+
+static const struct xenbus_device_id i2cfront_ids[] = {
+	{ "vi2c" },
+	{ "" },
+};
+
+static struct xenbus_driver i2cfront_driver = {
+	.ids = i2cfront_ids,
+	.probe = i2cfront_probe,
+	.otherend_changed = i2cfront_backend_changed,
+	.remove = i2cfront_remove,
+};
+
+static int __init i2cfront_init(void)
+{
+	if (!xen_domain())
+		return -ENODEV;
+
+	return xenbus_register_frontend(&i2cfront_driver);
+}
+subsys_initcall(i2cfront_init);
diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c
index 4ad665757..e9d6b12ec 100644
--- a/drivers/i2c/muxes/i2c-mux-pca954x.c
+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c
@@ -59,6 +59,7 @@ enum pca_type {
 	pca_9546,
 	pca_9547,
 	pca_9548,
+	pca_9646,
 	pca_9846,
 	pca_9847,
 	pca_9848,
@@ -140,6 +141,11 @@ static const struct chip_desc chips[] = {
 		.muxtype = pca954x_isswi,
 		.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },
 	},
+	[pca_9646] = {
+		.nchans = 4,
+		.muxtype = pca954x_isswi,
+		.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },
+	},
 	[pca_9846] = {
 		.nchans = 4,
 		.muxtype = pca954x_isswi,
@@ -185,6 +191,7 @@ static const struct i2c_device_id pca954x_id[] = {
 	{ "pca9546", pca_9546 },
 	{ "pca9547", pca_9547 },
 	{ "pca9548", pca_9548 },
+	{ "pca9646", pca_9646 },
 	{ "pca9846", pca_9846 },
 	{ "pca9847", pca_9847 },
 	{ "pca9848", pca_9848 },
@@ -202,6 +209,7 @@ static const struct of_device_id pca954x_of_match[] = {
 	{ .compatible = "nxp,pca9546", .data = &chips[pca_9546] },
 	{ .compatible = "nxp,pca9547", .data = &chips[pca_9547] },
 	{ .compatible = "nxp,pca9548", .data = &chips[pca_9548] },
+	{ .compatible = "nxp,pca9646", .data = &chips[pca_9646] },
 	{ .compatible = "nxp,pca9846", .data = &chips[pca_9846] },
 	{ .compatible = "nxp,pca9847", .data = &chips[pca_9847] },
 	{ .compatible = "nxp,pca9848", .data = &chips[pca_9848] },
diff --git a/drivers/i2c/muxes/i2c-mux-reg.c b/drivers/i2c/muxes/i2c-mux-reg.c
index 30a6de169..0e0679f65 100644
--- a/drivers/i2c/muxes/i2c-mux-reg.c
+++ b/drivers/i2c/muxes/i2c-mux-reg.c
@@ -183,12 +183,13 @@ static int i2c_mux_reg_probe(struct platform_device *pdev)
 	if (!mux->data.reg) {
 		dev_info(&pdev->dev,
 			"Register not set, using platform resource\n");
-		mux->data.reg = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		mux->data.reg_size = resource_size(res);
+		mux->data.reg = devm_ioremap_resource(&pdev->dev, res);
 		if (IS_ERR(mux->data.reg)) {
 			ret = PTR_ERR(mux->data.reg);
 			goto err_put_parent;
 		}
-		mux->data.reg_size = resource_size(res);
 	}
 
 	if (mux->data.reg_size != 4 && mux->data.reg_size != 2 &&
diff --git a/include/xen/interface/io/i2cif.h b/include/xen/interface/io/i2cif.h
new file mode 100644
index 000000000..c50467042
--- /dev/null
+++ b/include/xen/interface/io/i2cif.h
@@ -0,0 +1,95 @@
+/******************************************************************************
+ * i2cif.h
+ *
+ * I2C device I/O interface for Xen guest OSes.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2018-2019 NXP
+ *
+ * Authors: Peng Fan <peng.fan@nxp.com>
+ */
+
+#ifndef __XEN_PUBLIC_IO_I2CIF_H__
+#define __XEN_PUBLIC_IO_I2CIF_H__
+
+#include <xen/interface/io/ring.h>
+#include <xen/interface/grant_table.h>
+
+#define I2CIF_BUF_LEN	I2C_SMBUS_BLOCK_MAX + 2
+#define I2CIF_MAX_MSG	2
+
+#define I2CIF_M_RD		0x0001	/* read data, from slave to master */
+					/* I2C_M_RD is guaranteed to be 0x0001! */
+#define I2CIF_M_TEN		0x0010	/* this is a ten bit chip address */
+#define I2CIF_M_RECV_LEN	0x0400	/* length will be first received byte */
+#define I2CIF_M_NO_RD_ACK	0x0800	/* if I2CIF_FUNC_PROTOCOL_MANGLING */
+#define I2CIF_M_IGNORE_NAK	0x1000	/* if I2CIF_FUNC_PROTOCOL_MANGLING */
+#define I2CIF_M_REV_DIR_ADDR	0x2000	/* if I2CIF_FUNC_PROTOCOL_MANGLING */
+#define I2CIF_M_NOSTART		0x4000	/* if I2CIF_FUNC_NOSTART */
+#define I2CIF_M_STOP		0x8000	/* if I2CIF_FUNC_PROTOCOL_MANGLING */
+
+#define I2CIF_FUNC_I2C				0x00000001
+#define I2CIF_FUNC_10BIT_ADDR			0x00000002
+#define I2CIF_FUNC_PROTOCOL_MANGLING		0x00000004 /* I2C_M_IGNORE_NAK etc. */
+#define I2CIF_FUNC_SMBUS_PEC			0x00000008
+#define I2CIF_FUNC_NOSTART			0x00000010 /* I2C_M_NOSTART */
+#define I2CIF_FUNC_SLAVE			0x00000020
+#define I2CIF_FUNC_SMBUS_BLOCK_PROC_CALL	0x00008000 /* SMBus 2.0 */
+#define I2CIF_FUNC_SMBUS_QUICK			0x00010000
+#define I2CIF_FUNC_SMBUS_READ_BYTE		0x00020000
+#define I2CIF_FUNC_SMBUS_WRITE_BYTE		0x00040000
+#define I2CIF_FUNC_SMBUS_READ_BYTE_DATA		0x00080000
+#define I2CIF_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000
+#define I2CIF_FUNC_SMBUS_READ_WORD_DATA		0x00200000
+#define I2CIF_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000
+#define I2CIF_FUNC_SMBUS_PROC_CALL		0x00800000
+#define I2CIF_FUNC_SMBUS_READ_BLOCK_DATA	0x01000000
+#define I2CIF_FUNC_SMBUS_WRITE_BLOCK_DATA	0x02000000
+#define I2CIF_FUNC_SMBUS_READ_I2C_BLOCK		0x04000000 /* I2C-like block xfer  */
+#define I2CIF_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* w/ 1-byte reg. addr. */
+#define I2CIF_FUNC_SMBUS_HOST_NOTIFY		0x10000000
+
+#define I2CIF_ADAPTER_NAME_LEN	32
+
+struct i2cif_request {
+	struct {
+		__u16 addr;	/* slave address */
+		__u16 flags;	/* msg flags */
+		__u16 len;	/* msg length */
+	} msg[I2CIF_MAX_MSG];
+	int num_msg;
+	__u8 write_buf[I2CIF_BUF_LEN];
+
+	bool is_smbus;
+	__u16 addr;
+	__u16 flags;
+	__u8 read_write;
+	__u8 command;
+	int protocol;
+};
+
+struct i2cif_response {
+	int result;
+	__u8 read_buf[I2CIF_BUF_LEN];
+};
+
+DEFINE_RING_TYPES(i2cif, struct i2cif_request, struct i2cif_response);
+
+#endif
-- 
2.25.1

